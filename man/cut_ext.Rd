% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cut_ext.R
\name{cut_ext}
\alias{cut_ext}
\alias{cut_levels}
\title{Divide Numeric Into Intervals}
\usage{
cut_ext(
  x,
  breaks,
  right = TRUE,
  include.lowest = TRUE,
  data.name = substitute(x),
  ...
)

cut_levels(breaks, right = TRUE, include.lowest = TRUE, data.name = "x")
}
\arguments{
\item{x}{\link[base]{integer}, \link[base]{numeric}, \link[base]{difftime}, \link[base]{Date},
\link[base]{POSIXct} \link[base]{vector} or \link[base]{matrix}.}

\item{breaks}{\link[base]{vector} of the same \link[base]{class} as \code{x}.
\code{-Inf} and \code{Inf} will be automatically added to \code{breaks}}

\item{right}{\link[base]{logical} scalar, default \code{TRUE},
see \link[base]{cut.default} and \link[base]{.bincode}.}

\item{include.lowest}{\link[base]{logical} scalar, default \code{TRUE},
see \link[base]{cut.default} and \link[base]{.bincode}.}

\item{data.name}{\link[base]{character} scalar, name of data.
R objects which \link[base]{is.language} are also accepted.
Default is the argument call of \code{x}}

\item{...}{additional parameters, currently not in use}
}
\description{
Divide numeric into intervals.
An Alternative to \link[base]{cut.default}.
}
\details{
Function \link{cut_ext} is different from \link[base]{cut.default}, that
\itemize{
\item {More classes of \code{x} are accepted, see \strong{Arguments}}
\item {\code{-Inf} and \code{Inf} are added to \code{breaks},
so that the values outside of \code{breaks} will be correctly categorized,
instead of returning NA per \link[base]{.bincode}}
\item {More user-friendly factor levels, see helper function \link{cut_levels}}
}
}
\examples{
x = c(tmp <- c(10, 31, 45, 50, 52, NA, 55, 55, 57, 58.5, 60, 92), rev.default(tmp))
(xm = array(x, dim = c(6L, 4L)))
brk = c(20, 60, 80)
cut_ext(x, breaks = brk)
cut_ext(xm, breaks = brk)

(x2 = zoo::as.Date.ts(airmiles))
length(x2)
cut_ext(x2, breaks = as.Date(c('1942-01-01', '1950-01-01')))

x2a = x2
attr(x2a, 'dim') = c(4L, 6L)
cut_ext(x2a, breaks = as.Date(c('1942-01-01', '1950-01-01')))

x3 = 0:10
cut_ext(x3, breaks = c(0, 3, 6), right = FALSE)
cut_ext(x3, breaks = c(0, 3, 6), right = TRUE)

if (FALSE) {
# ?base::.bincode much faster than ?base::findInterval
x = 2:18
v = c(5, 10, 15) # create two bins [5,10) and [10,15)
findInterval(x, v)
.bincode(x, v)
library(microbenchmark)
microbenchmark(findInterval(x, v), .bincode(x, v))
}
 
## Examples on Helper Function cut_levels()
fn <- function(breaks) {
 print(levels(cut.default(numeric(0), breaks = breaks, right = TRUE, include.lowest = TRUE)))
 print(cut_levels(breaks, right = TRUE, include.lowest = TRUE))
 print(levels(cut.default(numeric(0), breaks = breaks, right = FALSE, include.lowest = TRUE)))
 print(cut_levels(breaks, right = FALSE, include.lowest = TRUE))
 print(levels(cut.default(numeric(0), breaks = breaks, right = TRUE, include.lowest = FALSE)))
 print(cut_levels(breaks, right = TRUE, include.lowest = FALSE))
 print(levels(cut.default(numeric(0), breaks = breaks, right = FALSE, include.lowest = FALSE)))
 print(cut_levels(breaks, right = FALSE, include.lowest = FALSE))
}
fn(breaks = 1:4)
fn(breaks = c(-Inf, 1:3, Inf))
set.seed(2259); fn(breaks = c(-Inf, sort(rnorm(1:3)), Inf))

}

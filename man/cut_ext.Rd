% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cut_ext.R
\name{cut_ext}
\alias{cut_ext}
\alias{cut_}
\alias{cut_levels}
\title{Divide Numeric Into Intervals}
\usage{
cut_(
  x,
  breaks,
  right = TRUE,
  include.lowest = TRUE,
  data.name = substitute(x),
  ...
)

cut_levels(breaks, right = TRUE, include.lowest = TRUE, data.name = "x")
}
\arguments{
\item{x}{\link[base]{integer}, \link[base]{numeric}, \link[base]{difftime}, \link[base]{Date},
\link[base]{POSIXct} \link[base]{vector} or \link[base]{matrix}.}

\item{breaks}{\link[base]{vector} of the same \link[base]{class} as \code{x}.
\code{-Inf} and \code{Inf} will be automatically added}

\item{right}{\link[base]{logical} scalar, default \code{TRUE},
see functions \link[base]{cut.default} and \link[base]{.bincode}.}

\item{include.lowest}{\link[base]{logical} scalar, default \code{TRUE},
see functions \link[base]{cut.default} and \link[base]{.bincode}.}

\item{data.name}{\link[base]{character} scalar, name of data.
R \link[base]{language} is also accepted.
Default is the argument call of \code{x}}

\item{...}{additional parameters, currently not in use}
}
\description{
Divide numeric into intervals; an alternative to function \link[base]{cut.default}.
}
\details{
Function \link{cut_} is different from function \link[base]{cut.default}, that
\itemize{
\item {More classes of \code{x} are accepted, see \strong{Arguments}}
\item {\code{-Inf} and \code{Inf} are added to \code{breaks},
so that the values outside of \code{breaks} will be correctly categorized,
instead of returning an \code{NA_integer} per \link[base]{.bincode}}
\item {More user-friendly \link[base]{factor} \link[base]{levels}, see helper function \link{cut_levels}}
}
}
\examples{
x = c(tmp <- c(10, 31, 45, 50, 52, NA, 55, 55, 57, 58.5, 60, 92), rev.default(tmp))
(xm = array(x, dim = c(6L, 4L)))
brk = c(20, 60, 80)
cut_(x, breaks = brk)
cut_(xm, breaks = brk)

(x2 = zoo::as.Date.ts(airmiles))
length(x2)
cut_(x2, breaks = as.Date(c('1942-01-01', '1950-01-01')))

x2a = x2
attr(x2a, 'dim') = c(4L, 6L)
cut_(x2a, breaks = as.Date(c('1942-01-01', '1950-01-01')))

x3 = 0:10
cut_(x3, breaks = c(0, 3, 6), right = FALSE)
cut_(x3, breaks = c(0, 3, 6), right = TRUE)

if (FALSE) {
# ?base::.bincode much faster than ?base::findInterval
x = 2:18
v = c(5, 10, 15) # create two bins [5,10) and [10,15)
findInterval(x, v)
.bincode(x, v)
library(microbenchmark)
microbenchmark(findInterval(x, v), .bincode(x, v))
}
 
## Examples on Helper Function cut_levels()
foo = function(...) cbind(
 levels(cut.default(numeric(0), ...)),
 cut_levels(...)
)
foo(breaks = 1:4, right = TRUE, include.lowest = TRUE)
foo(breaks = 1:4, right = FALSE, include.lowest = TRUE)
foo(breaks = 1:4, right = TRUE, include.lowest = FALSE)
foo(breaks = 1:4, right = FALSE, include.lowest = FALSE)
set.seed(2259); foo(breaks = c(-Inf, sort(rnorm(1:3)), Inf))
}
